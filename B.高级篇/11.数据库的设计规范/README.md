## 范式级别

由低到高：第一范式(1NF)、第二范式(2NF)、第三范式(3NF)，巴斯-科德范式(BCNF)、第四范式(4NF)、第五范式(5NF，又称完美范式)

![image-20221019112115013](image-20221019112115013.png)

一般来说，在关系型数据库中，最高也就遵循到`BCNF`，普遍还是`3NF`。有时为了提高某些查询性能，还需要破坏范式规则，也就是*反规范化*。

## 第一范式(1st NF)

确保数据表中每个字段的值必须具有**原子性 **，也就是说数据表中每个字段的值为**不可再次拆分**的最小数据单元。

## 第二范式(2nd NF)

满足第一范式的基础上，还要满足**数据表中的每一条数据记录，都是可唯一标识的。而且所有非主键字段都必须完全依赖主键，不能只依赖主键的一部分**。

## 第三范式(3rd NF)

满足第二范式的基础上，确保数据表中每一个非主键字段都和主键字段直接相关，也就是说，**要求数据表中的所有非主键字段不能依赖于其它非主键字段**。即，所有非主键属性之间不能有依赖关系，必须相互独立。

## 反范式化

当冗余信息有价值或者能大幅度提高查询效率时，才会采取反范式的设计。

增加冗余字段的条件：

- 该冗余字段不需要经常进行修改
- 该冗余字段查询时不可或缺

### 场景

- 历史快照、历史数据的需要

## BCNF(巴斯范式)

若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BCNF。

## 数据库对象编写建议

### 关于库

- 【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字 母开头。

- 【强制】库名中英文 一律小写 ，不同单词采用 下划线 分割。须见名知意。

- 【强制】库的名称格式:业务系统名称_子系统名。

- 【强制】库名禁止使用关键字(如type,order等)。

- 【强制】创建数据库时必须 显式指定字符集 ，并且字符集只能是utf8或者utf8mb4。

  创建数据库SQL举例:`CREATE DATABASE crm_fund DEFAULT CHARACTER SET 'utf8'` ;

- 【建议】对于程序连接数据库账号，遵循 权限最小原则

  使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号 原则上不准有`drop`权限 。

- 【建议】临时库以` tmp_ `为前缀，并以日期为后缀;

备份库以 `bak_` 为前缀，并以日期为后缀。

### 关于表、字段

- 【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议

  以 英文字母开头 。

- 【强制】 表名、列名一律小写 ，不同单词采用下划线分割。须见名知意。

- 【强制】表名要求有模块名强相关，同一模块的表名尽量使用 统一前缀 。比如:`crm_fund_item`

- 【强制】创建表时必须 显式指定字符集 为utf8或utf8mb4。

- 【强制】表名、列名禁止使用关键字(如type,order等)。

- 【强制】创建表时必须 显式指定表存储引擎 类型。如无特殊需求，一律为InnoDB。

- 【强制】建表必须有comment。

- 【强制】字段命名应尽可能使用表达实际含义的英文单词或 缩写 。如:公司 ID，不要使用 `corporation_id`, 而用`corp_id` 即可。

- 【强制】布尔值类型的字段命名为 `is_`描述 。如member表上表示是否为enabled的会员的字段命 名为 `is_enabled`。

- 【强制】禁止在数据库中存储图片、文件等大的二进制数据 通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。

- 【建议】建表时关于主键: 表必须有主键 (1)强制要求主键为id，类型为int或bigint，且为 auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议 设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机 插入，则会导致innodb内部页分裂和大量随机I/O，性能下降。

- 【建议】核心表(如用户表)必须有行数据的 创建时间字段 (create_time)和 最后更新时间字段 (update_time)，便于查问题。

- 【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT值 。 因为使用 NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问 题。

- 【建议】所有存储相同数据的 列名和列类型必须一致 (一般作为关联列，如果查询时关联列类型 不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低)。

- 【建议】中间表(或临时表)用于保留中间结果集，名称以 tmp_ 开头。 备份表用于备份或抓取源表快照，名称以 bak_ 开头。中间表和备份表定期清理。

- 【示范】一个较为规范的建表语句:

  ```sql
  CREATE TABLE user_info (
  `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',
  `user_id` bigint(11) NOT NULL COMMENT '用户id',
  `username` varchar(45) NOT NULL COMMENT '真实姓名',
  `email` varchar(30) NOT NULL COMMENT '用户邮箱',
  `nickname` varchar(45) NOT NULL COMMENT '昵称',
  `birthday` date NOT NULL COMMENT '生日',
  `sex` tinyint(4) DEFAULT '0' COMMENT '性别',
  `short_introduce` varchar(150) DEFAULT NULL COMMENT '一句话介绍自己，最多50个汉字', `user_resume` varchar(300) NOT NULL COMMENT '用户提交的简历存放地址', `user_register_ip` int NOT NULL COMMENT '用户注册时的源ip',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE
  CURRENT_TIMESTAMP COMMENT '修改时间',
  `user_review_status` tinyint NOT NULL COMMENT '用户资料审核状态，1为通过，2为审核中，3为未
  通过，4为还未提交审核',
    
  ```

  

- 【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。 实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。

  可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构 的导出和导入。

###  关于索引

- 【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值 禁止被更新 。

- 【强制】InnoDB和MyISAM存储引擎表，索引类型必须为 BTREE 。

- 【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。

- 【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如:

  sample 表 member_id 上的索引:idx_sample_mid。

- 【建议】单个表上的索引个数不能超过6个 。

- 【建议】在建立索引时，多考虑建立 联合索引，并把区分度最高的字段放在最前面。

- 【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。

- 【建议】建表或加索引时，保证表里互相不存在 冗余索引 。 比如:如果表里已经存在key(a,b)，则key(a)为冗余索引，需要删除。

### SQL 编写

- 【强制】程序端`SELECT`语句必须指定具体字段名称，禁止写成 `*`。

- 【建议】程序端`insert`语句指定具体字段名称，不要写成`INSERT INTO t1 VALUES(...)`。

- 【建议】除静态表或小表(100行以内)，DML语句必须有`WHERE`条件，且使用索引查找。

- 【建议】`INSERT INTO...VALUES(XX),(XX),(XX).. `这里XX的值不要超过5000个。 值过多虽然上线很 快，但会引起主从同步延迟。

- 【建议】`SELECT`语句不要使用`UNION`，推荐使用`UNION ALL`，并且`UNION子`句个数限制在5个以 内。

- 【建议】线上环境，多表` JOIN `不要超过5个表。

- 【建议】减少使用`ORDER BY`，和业务沟通能不排序就不排序，或将排序放到程序端去做。`ORDER BY`、`GROUP BY`、`DISTINCT `这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。

- 【建议】包含了`ORDER BY`、`GROUP BY`、`DISTINCT` 这些查询的语句，`WHERE` 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。

- 【建议】对单表的多次`alte`r操作必须合并为一次

  对于超过100W行的大表进行`alter table`，必须经过DBA审核，并在业务低峰期执行，多个alter需整 合在一起。 因为alter table会产生 表锁 ，期间阻塞对于该表的所有写入，对于业务可能会产生极 大影响。

- 【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。

- 【建议】事务里包含SQL不超过5个。

  因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。

- 【建议】事务里更新语句尽量基于主键或`UNIQUE KEY`，如`UPDATE... WHERE id=XX;`否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。